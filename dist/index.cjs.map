{"version":3,"sources":["../src/index.ts","../src/utils/client.ts","../src/errors/ConnectorNotFoundError.ts","../src/errors/ConnectorAlreadyConnectedError.ts","../src/errors/ClientNotFoundError.ts","../src/enums/status.ts","../src/actions/account/connect.ts","../src/actions/account/disconnect.ts","../src/actions/account/isConnected.ts","../src/actions/account/getActivePublicKey.ts","../src/actions/account/watchAccount.ts","../src/utils/deepEqual.ts","../src/actions/account/getAccount.ts","../src/actions/signing/sign.ts","../src/actions/signing/signMessage.ts","../src/connectors/base.ts","../src/connectors/casperDash.ts","../src/connectors/casperSigner.ts"],"sourcesContent":["export * from './actions/account';\nexport * from './actions/signing';\n\nexport * from './connectors';\n\nexport * from './utils';\n\nexport * from './enums';\n\nexport * from './errors';\n","import { createStore, Mutate, StoreApi } from 'zustand/vanilla';\nimport { subscribeWithSelector } from 'zustand/middleware';\n\nimport { Connector, ConnectorData } from '../connectors/base';\nimport { ClientNotFoundError } from '../errors';\nimport { StatusEnum } from '../enums';\n\nexport type StateParams = {\n  connectors: Connector[];\n  connector?: Connector;\n  data?: ConnectorData;\n  status?: StatusEnum;\n  autoConnect?: boolean;\n};\n\n\nexport type ClientConfig = StateParams;\n\nexport class Client {\n  private store: Mutate<\n  StoreApi<StateParams>,\n  [\n    ['zustand/subscribeWithSelector', never],\n  ]\n  >;\n\n  private isAutoConnecting: boolean | undefined;\n\n  constructor({\n    autoConnect = false,\n    connectors,\n  }: ClientConfig) {\n    this.store = createStore(subscribeWithSelector(() => ({\n      connectors: connectors,\n      status: StatusEnum.DISCONNECTED,\n      autoConnect,\n    })));\n\n    this.triggerEvent();\n\n    if (autoConnect) {\n      setTimeout(async () => this.autoConnect(), 0);\n    }\n  }\n\n  public get state() {\n    return this.store.getState();\n  }\n\n  public get connector(): Connector | undefined {\n    return this.store.getState().connector;\n  }\n\n  public get connectors(): Connector[] | undefined {\n    return this.store.getState().connectors;\n  }\n\n  public get subscribe() {\n    return this.store.subscribe;\n  }\n\n  public get data() {\n    return this.store.getState().data;\n  }\n\n  public get status() {\n    return this.store.getState().status;\n  }\n\n  public clearState() {\n    this.setState((x: StateParams) => ({\n      ...x,\n      connector: undefined,\n      data: undefined,\n    }));\n  }\n\n  public setState(\n    updater:\n    | Partial<StateParams>\n    | ((\n      state: StateParams,\n    ) => StateParams),\n  ) {\n    const newState =\n      typeof updater === 'function' ? updater(this.store.getState()) : updater;\n    this.store.setState(newState, true);\n  }\n\n  protected async autoConnect() {\n    if (this.isAutoConnecting) {\n      return;\n    }\n    if (this.status === StatusEnum.CONNECTED) {\n      return;\n    }\n    this.isAutoConnecting = true;\n\n    this.setState((x: StateParams) => ({\n      ...x,\n      status: x.data?.activeKey ? StatusEnum.RECONNECTING : StatusEnum.CONNECTING,\n    }));\n\n\n    let isConnected = false;\n    for (const connector of this.connectors || []) {\n      const isConnectedWithConnector = await connector?.isConnected();\n\n      if (isConnectedWithConnector) {\n        await this.connector?.connect();\n        const publicKey = await connector?.getActivePublicKey();\n        this.setState((x: StateParams) => ({\n          ...x,\n          status: StatusEnum.CONNECTED,\n          connector,\n          data: {\n            ...x.data,\n            activeKey: publicKey,\n          },\n        }));\n        isConnected = true;\n\n        break;\n      }\n    }\n\n    if (!isConnected) {\n      this.setState((x: StateParams) => ({\n        ...x,\n        status: StatusEnum.DISCONNECTED,\n      }));\n    }\n\n    this.isAutoConnecting = false;\n\n    return this.data;\n  }\n\n  private triggerEvent(): void {\n    const onChange = (data: ConnectorData) => {\n      this.setState((x: StateParams) => ({\n        ...x,\n        data: { ...x.data, ...data },\n      }));\n    };\n\n    const onDisconnect = () => {\n      this.clearState();\n    };\n\n    const onConnect = (data: ConnectorData) => {\n      this.setState((x: StateParams) => ({\n        ...x,\n        data: { ...x.data, ...data },\n        status: StatusEnum.CONNECTED,\n      }));\n    };\n\n    this.store.subscribe(\n      ({ connector }: StateParams) => connector!,\n      (connector: Connector) => {\n        if (!connector) return;\n        window?.addEventListener('casper:change',\n          (event: CustomEventInit<{ activeKey: string; isConnected: boolean }>) => onChange(event.detail!));\n        window?.addEventListener('casper:disconnect', () => onDisconnect());\n        window?.addEventListener('casper:connect',\n          (event: CustomEventInit<{ activeKey: string; isConnected: boolean }>) => onConnect(event.detail!));\n      },\n    );\n  }\n\n\n}\n\nexport let client: Client;\n\nexport const createClient = (clientConfig: ClientConfig): Client => {\n  client = new Client(clientConfig);\n\n  return client;\n};\n\nexport const getClient = (): Client => {\n  if (!client) {\n    throw new ClientNotFoundError();\n  }\n\n  return client;\n};\n","export class ConnectorNotFoundError extends Error {\n  public name: string = 'ConnectorNotFoundError';\n  public message: string = 'Connector not found';\n}\n","export class ConnectorAlreadyConnectedError extends Error {\n  public name: string = 'ConnectorAlreadyConnectedError';\n  public message: string = 'Connector already connected';\n}\n","export class ClientNotFoundError extends Error {\n  public name: string = 'ClientNotFoundError';\n  public message: string = 'Client not found';\n}\n","export enum StatusEnum {\n  CONNECTED = 'connected',\n  CONNECTING = 'connecting',\n  RECONNECTING = 'reconnecting',\n  DISCONNECTED = 'disconnected',\n}\n","import { Connector, StatusEnum, ConnectorAlreadyConnectedError } from '@usedapp/core';\nimport { getClient, StateParams } from '@usedapp/core/utils/client';\n\nexport type ConnectParams = {\n  connector: Connector;\n};\n\nexport type ConnectResult = {\n  connector: Connector;\n};\n\nexport const connect = async ({ connector }: ConnectParams): Promise<ConnectResult> => {\n  const client = getClient();\n  const activeConnector = client?.connector;\n\n  if (activeConnector && activeConnector.id !== connector.id) {\n    throw new ConnectorAlreadyConnectedError();\n  }\n\n  try {\n    client.setState((x: StateParams) => ({ ...x, status: StatusEnum.CONNECTING }));\n    await connector.connect();\n    let customData = {};\n    let isConnected = false;\n\n    try {\n      const activeKey = await connector.getActivePublicKey();\n      customData = {\n        activeKey: activeKey,\n      };\n      isConnected = !!activeKey;\n    } catch (err) {\n      console.error(err);\n    }\n\n    client.setState((oldState: StateParams) => ({\n      ...oldState,\n      connector,\n      status: isConnected ? StatusEnum.CONNECTED : StatusEnum.CONNECTING,\n      data: {\n        ...oldState.data,\n        ...customData,\n      },\n    }));\n\n    return {\n      connector,\n    };\n  } catch (error) {\n    console.error(error);\n\n    throw error;\n  }\n};\n","import { StatusEnum } from '@usedapp/core/enums';\nimport { getClient, StateParams } from '@usedapp/core/utils/client';\n\nexport const disconnect = async (): Promise<void> => {\n  const client = getClient();\n\n  try {\n    await client.connector?.disconnect();\n    client.setState((oldState: StateParams) => ({\n      ...oldState,\n      status: StatusEnum.DISCONNECTED,\n      data: {\n        ...oldState.data,\n        activeKey: undefined,\n      },\n    }));\n  } catch (error) {\n    console.error(error);\n  }\n};\n","import { getClient } from '@usedapp/core/utils/client';\n\nexport const isConnected = async (): Promise<boolean> => {\n  const connector = getClient()?.connector;\n\n  try {\n    const hasConnected = await connector?.isConnected();\n\n    return !!hasConnected;\n  } catch (error) {\n    console.error(error);\n    return false;\n  }\n};\n","import { getClient } from '@usedapp/core/utils/client';\n\nexport const getActivePublicKey = async (): Promise<string | undefined> => {\n  const connector = getClient()?.connector;\n\n  try {\n    const activeKey = await connector?.getActivePublicKey();\n\n    return activeKey;\n  } catch (error) {\n    console.error(error);\n  }\n};\n","import { shallow } from 'zustand/shallow';\nimport { Connector } from '@usedapp/core/connectors/base';\nimport { StatusEnum } from '@usedapp/core/enums';\nimport { getClient, StateParams } from '@usedapp/core/utils/client';\n\nimport { Account, getAccount } from './getAccount';\n\nexport type Acount = {\n  publicKey: string;\n};\n\nexport type WatchAccountSelectorParams = {\n  publicKey?: string;\n  connector?: Connector;\n  status?: StatusEnum;\n};\n\nexport type WatchAccountOptions = {\n  selector?: ({\n    publicKey,\n    connector,\n    status,\n  }: WatchAccountSelectorParams) => any;\n};\n\nexport const watchAccount = (\n  callback: (account: Account | null) => void,\n  { selector = (params: WatchAccountSelectorParams) => params } : WatchAccountOptions = {}): any => {\n  const client = getClient();\n\n  const handleOnChange = () => callback(getAccount());\n  const unsubscribe = client.subscribe(\n    ({ data, connector, status }: StateParams) => {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      return selector?.({\n        publicKey: data?.activeKey,\n        status,\n        connector,\n      });\n    },\n    handleOnChange,\n    {\n      equalityFn: shallow,\n    },\n  );\n\n  return unsubscribe;\n};\n","export const deepEqual = (a: any, b: any) => {\n  // check if a and b are both null or undefined\n  if (a === null && b === null) return true;\n  if (a === undefined && b === undefined) return true;\n\n  // check if a and b are of the same type\n  if (typeof a !== typeof b) return false;\n\n  // check if a and b are both primitive types\n  if (typeof a !== 'object') return a === b;\n\n  // check if a and b have the same number of properties\n  if (Object.keys(a as Record<any, any>).length !== Object.keys(b as Record<any, any>).length) return false;\n\n  // check if all properties of a exist in b and are equal\n  // eslint-disable-next-line no-restricted-syntax\n  for (const key in a) {\n    if (!Object.prototype.hasOwnProperty.call(b, key)) return false;\n    if (!deepEqual(a[key], b[key])) return false;\n  }\n\n  return true;\n};\n","import { Connector } from '@usedapp/core/connectors';\nimport { StatusEnum } from '@usedapp/core/enums';\nimport { getClient } from '@usedapp/core/utils';\n\nexport type Account = {\n  publicKey?: string;\n  status?: StatusEnum;\n  connector?: Connector;\n};\n\nexport const getAccount = (): Account | null => {\n  try {\n    const client = getClient();\n    const { data, status, connector } = client;\n\n    return {\n      publicKey: data?.activeKey,\n      status,\n      connector,\n    };\n  } catch (error) {\n    console.error(error);\n\n    return null;\n  }\n};\n","import { getClient } from '@usedapp/core/utils/client';\nimport { JsonTypes } from 'typedjson';\n\nexport type SignParams = {\n  deploy: unknown;\n  signingPublicKey: string;\n  targetPublicKeyHex: string;\n};\n\nexport type SignResult = { deploy: JsonTypes } | undefined;\n\nexport const sign = async ({ deploy, signingPublicKey, targetPublicKeyHex }: SignParams): Promise<SignResult> => {\n  const connector = getClient()?.connector;\n\n  try {\n    return await connector?.sign(deploy, signingPublicKey, targetPublicKeyHex);\n  } catch (error) {\n    console.error(error);\n  }\n};\n","import { getClient } from '@usedapp/core/utils/client';\n\nexport type SignMessageParams = {\n  message: string;\n  signingPublicKey: string;\n};\n\nexport type SignMessageResult = string | undefined;\n\nexport const signMessage = async ({ message, signingPublicKey }: SignMessageParams): Promise<SignMessageResult> => {\n  const connector = getClient()?.connector;\n\n  try {\n    return await connector?.signMessage(message, signingPublicKey);\n  } catch (error) {\n    console.error(error);\n  }\n};\n","import { default as EventEmitter } from 'eventemitter3';\nimport { JsonTypes } from 'typedjson';\n\nexport type ConnectorData<Provider = unknown> = {\n  activeKey?: string;\n  isConnected?: boolean;\n  provider?: Provider;\n};\n\nexport interface ConnectorEvents {\n  change(data: ConnectorData): void;\n  connect(data: ConnectorData): void;\n  message({ type, data }: { type: string; data?: unknown }): void;\n  disconnect(): void;\n  error(error: Error): void;\n}\n\nexport abstract class Connector<Provider = unknown, EventProvider = unknown, Options = unknown> extends EventEmitter<ConnectorEvents> {\n  protected readonly options: Options;\n  public abstract readonly id: string;\n\n  constructor({\n    options,\n  }: {\n    options: Options;\n  }) {\n    super();\n    this.options = options;\n  }\n\n  public getOptions() {\n    return this.options;\n  }\n\n  public abstract getProvider(): Promise<Provider>;\n  public abstract getEventProvider(): Promise<EventProvider>;\n\n  public abstract isConnected(): Promise<boolean>;\n  public abstract disconnect(): Promise<void>;\n  public abstract connect(): Promise<void>;\n  public abstract getActivePublicKey(): Promise<string>;\n  public abstract signMessage(message:string, signingPublicKey: string): Promise<string>;\n  public abstract sign(deploy: unknown, signingPublicKeyHex: string, targetPublicKeyHex: string): Promise<{ deploy: JsonTypes }>;\n\n  public abstract onConnected(event: CustomEventInit): void;\n  public abstract onDisconnected(): void;\n  public abstract onActiveKeyChanged(event: CustomEventInit): void;\n}\n","import { JsonTypes } from 'typedjson';\n\nimport { ConnectorNotFoundError } from '../errors';\n\nimport { Connector } from './base';\n\ndeclare global {\n  interface Window {\n    casperDashPluginHelpers?: {\n      isConnected: () => Promise<boolean>;\n      signMessage: (message: string, signingPublicKey: string) => Promise<string>;\n      sign: (deploy: unknown, signingPublicKey: string, targetPublicKey: string) => Promise<{ deploy: JsonTypes }>;\n      disconnectFromSite: () => Promise<void>;\n      requestConnection: () => Promise<void>;\n      getActivePublicKey: () => Promise<string>;\n    };\n  }\n}\n\ntype CasperDashWindowGlobal = Window['casperDashPluginHelpers'];\ntype Provider = CasperDashWindowGlobal;\ntype EventProvider = Window;\n\nexport type CasperDashConnectorOptions = {\n  name?: string;\n  getProvider?: () => Provider;\n  getEventProvider?: () => EventProvider;\n};\n\nexport class CasperDashConnector extends Connector<CasperDashWindowGlobal, Window, CasperDashConnectorOptions> {\n  public readonly id: string = 'casperDash';\n\n  private provider: Provider;\n  private eventProvider: Window | undefined;\n\n  constructor({\n    options: defaultOptions,\n  }: { options?: CasperDashConnectorOptions } = {}) {\n    const options: CasperDashConnectorOptions = {\n      name: 'CasperDash',\n      getProvider: (): Provider | undefined => {\n        return typeof window !== 'undefined' ? window.casperDashPluginHelpers : undefined;\n      },\n      getEventProvider: (): EventProvider => {\n        return window;\n      },\n      ...defaultOptions,\n    };\n\n    super({ options });\n  }\n\n  public async getProvider(): Promise<CasperDashWindowGlobal> {\n    const provider = this.options.getProvider?.();\n    if (!provider) {\n      throw new ConnectorNotFoundError();\n    }\n    this.provider = provider;\n\n    return this.provider;\n  }\n\n  public async getEventProvider(): Promise<EventProvider> {\n    const eventProvider = this.options.getEventProvider?.();\n    if (!eventProvider) {\n      throw new ConnectorNotFoundError();\n    }\n\n    this.eventProvider = eventProvider;\n\n    return this.eventProvider;\n  }\n\n  public async isConnected(): Promise<boolean> {\n    try {\n      const provider = await this.getProvider();\n\n      return await provider!.isConnected();\n    } catch (err) {\n      return false;\n    }\n  }\n\n  public async disconnect(): Promise<void> {\n    const provider = await this.getProvider();\n\n    const eventProvider = await this.getEventProvider();\n\n    eventProvider?.removeEventListener('casperdash:activeKeyChanged', this.onActiveKeyChanged);\n    eventProvider?.removeEventListener('casperdash:disconnected', () => this.onDisconnected());\n    eventProvider?.removeEventListener('casperdash:connected', this.onConnected);\n\n    await provider!.disconnectFromSite();\n  }\n\n  public async connect(): Promise<void> {\n    const provider = await this.getProvider();\n\n    const eventProvider = await this.getEventProvider();\n\n    eventProvider?.addEventListener('casperdash:activeKeyChanged', this.onActiveKeyChanged);\n    eventProvider?.addEventListener('casperdash:disconnected', this.onDisconnected);\n    eventProvider?.addEventListener('casperdash:connected', this.onConnected);\n\n    await provider!.requestConnection();\n  }\n\n  public async getActivePublicKey(): Promise<any> {\n    const provider = await this.getProvider();\n\n    return provider!.getActivePublicKey();\n  }\n\n  public async signMessage(message: string, signingPublicKey: string): Promise<string> {\n    const provider = await this.getProvider();\n\n    return provider!.signMessage(message, signingPublicKey);\n  }\n\n  public async sign(deploy: any, signingPublicKey: string, targetPublicKey: string): Promise<{ deploy: JsonTypes }> {\n    const provider = await this.getProvider();\n\n    return provider!.sign(deploy, signingPublicKey, targetPublicKey);\n  }\n\n  public onDisconnected(): void {\n    const customEvent = new CustomEvent('casper:disconnect');\n    window.dispatchEvent(customEvent);\n    // this.emit('disconnect');\n  }\n\n  public onActiveKeyChanged(event: CustomEventInit<{ activeKey: string; isConnected: boolean }>): void {\n    const customEvent = new CustomEvent('casper:change', event);\n    window.dispatchEvent(customEvent);\n    // this.emit('change', { isConnected: event.detail?.isConnected, activeKey: event.detail?.activeKey });\n  }\n\n  public onConnected(event: CustomEventInit<{ activeKey: string; isConnected: boolean }>): void {\n    const customEvent = new CustomEvent('casper:connect', event);\n    window.dispatchEvent(customEvent);\n    // this.emit('connect', { isConnected: event.detail?.isConnected, activeKey: event.detail?.activeKey });\n  }\n}\n","import { JsonTypes } from 'typedjson';\n\nimport { ConnectorNotFoundError } from '../errors';\nimport { CasperLabsHelper } from '../types/casperLabsHelper';\n\nimport { Connector } from './base';\n\ndeclare global {\n  interface Window {\n    casperlabsHelper: CasperLabsHelper;\n  }\n}\n\n\ntype CasperLabWindowGlobal = CasperLabsHelper;\ntype Provider = CasperLabsHelper;\ntype EventProvider = Window;\n\nexport type CasperSignerConnectorOptions = {\n  name?: string;\n  getProvider?: () => Provider | undefined;\n  getEventProvider?: () => EventProvider;\n};\n\nexport class CasperSignerConnector extends Connector<CasperLabWindowGlobal, Window, CasperSignerConnectorOptions> {\n  public readonly id: string = 'casperSigner';\n\n  private provider: Provider | undefined;\n  private eventProvider: Window | undefined;\n\n  constructor({\n    options: defaultOptions,\n  }: { options?: CasperSignerConnectorOptions } = {}) {\n    const options = {\n      name: 'CasperSigner',\n      getProvider: (): Provider | undefined => {\n        return typeof window !== 'undefined' ? window.casperlabsHelper : undefined;\n      },\n      getEventProvider: (): EventProvider => {\n        return window;\n      },\n      ...defaultOptions,\n    };\n\n    super({ options });\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  public async getProvider(): Promise<CasperLabWindowGlobal> {\n    const provider = this.options.getProvider?.();\n    if (!provider) {\n      throw new ConnectorNotFoundError();\n    }\n    this.provider = provider;\n\n    return this.provider;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  public async getEventProvider(): Promise<EventProvider> {\n    const eventProvider = this.options.getEventProvider?.();\n    if (!eventProvider) {\n      throw new ConnectorNotFoundError();\n    }\n\n    this.eventProvider = eventProvider;\n\n    return this.eventProvider;\n  }\n\n  public async isConnected(): Promise<boolean> {\n    try {\n      const provider = await this.getProvider();\n\n      return await provider.isConnected();\n    } catch (err) {\n      return false;\n    }\n  }\n\n  public async disconnect(): Promise<void> {\n    const provider = await this.getProvider();\n\n    const eventProvider = await this.getEventProvider();\n\n    eventProvider?.removeEventListener('signer:activeKeyChanged', this.onActiveKeyChanged);\n    eventProvider?.removeEventListener('signer:disconnected', this.onDisconnected);\n    eventProvider?.removeEventListener('signer:connected', this.onConnected);\n\n    provider.disconnectFromSite();\n  }\n\n  public async connect(): Promise<void> {\n    const provider = await this.getProvider();\n\n    const eventProvider = await this.getEventProvider();\n\n    eventProvider?.addEventListener('signer:activeKeyChanged', this.onActiveKeyChanged);\n    eventProvider?.addEventListener('signer:disconnected',  this.onDisconnected);\n    eventProvider?.addEventListener('signer:connected', this.onConnected);\n\n    provider.requestConnection();\n  }\n\n  public async getActivePublicKey(): Promise<string> {\n    const provider = await this.getProvider();\n\n    return provider.getActivePublicKey();\n  }\n\n  public async signMessage(message: string, signingPublicKey: string): Promise<string> {\n    const provider = await this.getProvider();\n\n    return provider.signMessage(message, signingPublicKey);\n  }\n\n  public async sign(deploy: any, signingPublicKeyHex: string, targetPublicKeyHex: string): Promise<{ deploy: JsonTypes }> {\n    const provider = await this.getProvider();\n\n    return provider.sign(deploy, signingPublicKeyHex, targetPublicKeyHex);\n  }\n\n  public onDisconnected(): void {\n    const customEvent = new CustomEvent('casper:disconnect');\n    window.dispatchEvent(customEvent);\n    // this.emit('disconnect');\n  }\n\n  public onActiveKeyChanged(event: CustomEventInit<{ activeKey: string; isConnected: boolean }>): void {\n    const customEvent = new CustomEvent('casper:change', event);\n    window.dispatchEvent(customEvent);\n    // this.emit('change', { isConnected: event.detail?.isConnected, activeKey: event.detail?.activeKey });\n  }\n\n  public onConnected(event: CustomEventInit<{ activeKey: string; isConnected: boolean }>): void {\n    const customEvent = new CustomEvent('casper:connect', event);\n    window.dispatchEvent(customEvent);\n    // this.emit('connect', { isConnected: event.detail?.isConnected, activeKey: event.detail?.activeKey });\n  }\n}\n"],"mappings":"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","names":["Connector","StatusEnum","isConnected","client","isConnected","client","client","client","Connector","EventEmitter","Connector","Connector"]}