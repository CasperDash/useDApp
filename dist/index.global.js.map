{"version":3,"sources":["../../../node_modules/.pnpm/eventemitter3@4.0.7/node_modules/eventemitter3/index.js","../../../node_modules/.pnpm/zustand@4.3.2/node_modules/zustand/esm/vanilla.mjs","../../../node_modules/.pnpm/zustand@4.3.2/node_modules/zustand/esm/middleware.mjs","../src/errors/ConnectorNotFoundError.ts","../src/errors/ConnectorAlreadyConnectedError.ts","../src/errors/ClientNotFoundError.ts","../src/enums/status.ts","../src/utils/client.ts","../src/actions/account/connect.ts","../src/actions/account/disconnect.ts","../src/actions/account/isConnected.ts","../src/actions/account/getActivePublicKey.ts","../../../node_modules/.pnpm/zustand@4.3.2/node_modules/zustand/esm/shallow.mjs","../src/utils/deepEqual.ts","../src/actions/account/getAccount.ts","../src/actions/account/watchAccount.ts","../src/actions/signing/sign.ts","../src/actions/signing/signMessage.ts","../src/connectors/base.ts","../src/connectors/casperDash.ts","../src/connectors/casperSigner.ts"],"sourcesContent":["'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","const createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\") ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const destroy = () => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\n        \"[DEPRECATED] The destroy method will be unsupported in the future version. You should use unsubscribe function returned by subscribe. Everything will be garbage collected if store is garbage collected.\"\n      );\n    }\n    listeners.clear();\n  };\n  const api = { setState, getState, subscribe, destroy };\n  state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\nvar vanilla = (createState) => {\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] default export is deprecated, instead import { createStore } ...\"\n    );\n  }\n  return createStore(createState);\n};\n\nexport { createStore, vanilla as default };\n","const reduxImpl = (reducer, initial) => (set, _get, api) => {\n  api.dispatch = (action) => {\n    set((state) => reducer(state, action), false, action);\n    return action;\n  };\n  api.dispatchFromDevtools = true;\n  return { dispatch: (...a) => api.dispatch(...a), ...initial };\n};\nconst redux = reduxImpl;\n\nconst trackedConnections = /* @__PURE__ */ new Map();\nconst getTrackedConnectionState = (name) => {\n  const api = trackedConnections.get(name);\n  if (!api)\n    return {};\n  return Object.fromEntries(\n    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])\n  );\n};\nconst extractConnectionInformation = (store, extensionConnector, options) => {\n  if (store === void 0) {\n    return {\n      type: \"untracked\",\n      connection: extensionConnector.connect(options)\n    };\n  }\n  const existingConnection = trackedConnections.get(options.name);\n  if (existingConnection) {\n    return { type: \"tracked\", store, ...existingConnection };\n  }\n  const newConnection = {\n    connection: extensionConnector.connect(options),\n    stores: {}\n  };\n  trackedConnections.set(options.name, newConnection);\n  return { type: \"tracked\", store, ...newConnection };\n};\nconst devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {\n  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;\n  let extensionConnector;\n  try {\n    extensionConnector = (enabled != null ? enabled : (import.meta.env && import.meta.env.MODE) !== \"production\") && window.__REDUX_DEVTOOLS_EXTENSION__;\n  } catch (e) {\n  }\n  if (!extensionConnector) {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\" && enabled) {\n      console.warn(\n        \"[zustand devtools middleware] Please install/enable Redux devtools extension\"\n      );\n    }\n    return fn(set, get, api);\n  }\n  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);\n  let isRecording = true;\n  api.setState = (state, replace, nameOrAction) => {\n    const r = set(state, replace);\n    if (!isRecording)\n      return r;\n    const action = nameOrAction === void 0 ? { type: anonymousActionType || \"anonymous\" } : typeof nameOrAction === \"string\" ? { type: nameOrAction } : nameOrAction;\n    if (store === void 0) {\n      connection == null ? void 0 : connection.send(action, get());\n      return r;\n    }\n    connection == null ? void 0 : connection.send(\n      {\n        ...action,\n        type: `${store}/${action.type}`\n      },\n      {\n        ...getTrackedConnectionState(options.name),\n        [store]: api.getState()\n      }\n    );\n    return r;\n  };\n  const setStateFromDevtools = (...a) => {\n    const originalIsRecording = isRecording;\n    isRecording = false;\n    set(...a);\n    isRecording = originalIsRecording;\n  };\n  const initialState = fn(api.setState, get, api);\n  if (connectionInformation.type === \"untracked\") {\n    connection == null ? void 0 : connection.init(initialState);\n  } else {\n    connectionInformation.stores[connectionInformation.store] = api;\n    connection == null ? void 0 : connection.init(\n      Object.fromEntries(\n        Object.entries(connectionInformation.stores).map(([key, store2]) => [\n          key,\n          key === connectionInformation.store ? initialState : store2.getState()\n        ])\n      )\n    );\n  }\n  if (api.dispatchFromDevtools && typeof api.dispatch === \"function\") {\n    let didWarnAboutReservedActionType = false;\n    const originalDispatch = api.dispatch;\n    api.dispatch = (...a) => {\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\" && a[0].type === \"__setState\" && !didWarnAboutReservedActionType) {\n        console.warn(\n          '[zustand devtools middleware] \"__setState\" action type is reserved to set state from the devtools. Avoid using it.'\n        );\n        didWarnAboutReservedActionType = true;\n      }\n      originalDispatch(...a);\n    };\n  }\n  connection.subscribe((message) => {\n    var _a;\n    switch (message.type) {\n      case \"ACTION\":\n        if (typeof message.payload !== \"string\") {\n          console.error(\n            \"[zustand devtools middleware] Unsupported action format\"\n          );\n          return;\n        }\n        return parseJsonThen(\n          message.payload,\n          (action) => {\n            if (action.type === \"__setState\") {\n              if (store === void 0) {\n                setStateFromDevtools(action.state);\n                return;\n              }\n              if (Object.keys(action.state).length !== 1) {\n                console.error(\n                  `\n                    [zustand devtools middleware] Unsupported __setState action format. \n                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),\n                    and value of this only key should be a state object. Example: { \"type\": \"__setState\", \"state\": { \"abc123Store\": { \"foo\": \"bar\" } } }\n                    `\n                );\n              }\n              const stateFromDevtools = action.state[store];\n              if (stateFromDevtools === void 0 || stateFromDevtools === null) {\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {\n                setStateFromDevtools(stateFromDevtools);\n              }\n              return;\n            }\n            if (!api.dispatchFromDevtools)\n              return;\n            if (typeof api.dispatch !== \"function\")\n              return;\n            api.dispatch(action);\n          }\n        );\n      case \"DISPATCH\":\n        switch (message.payload.type) {\n          case \"RESET\":\n            setStateFromDevtools(initialState);\n            if (store === void 0) {\n              return connection == null ? void 0 : connection.init(api.getState());\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"COMMIT\":\n            if (store === void 0) {\n              connection == null ? void 0 : connection.init(api.getState());\n              return;\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"ROLLBACK\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                connection == null ? void 0 : connection.init(api.getState());\n                return;\n              }\n              setStateFromDevtools(state[store]);\n              connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n            });\n          case \"JUMP_TO_STATE\":\n          case \"JUMP_TO_ACTION\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {\n                setStateFromDevtools(state[store]);\n              }\n            });\n          case \"IMPORT_STATE\": {\n            const { nextLiftedState } = message.payload;\n            const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;\n            if (!lastComputedState)\n              return;\n            if (store === void 0) {\n              setStateFromDevtools(lastComputedState);\n            } else {\n              setStateFromDevtools(lastComputedState[store]);\n            }\n            connection == null ? void 0 : connection.send(\n              null,\n              // FIXME no-any\n              nextLiftedState\n            );\n            return;\n          }\n          case \"PAUSE_RECORDING\":\n            return isRecording = !isRecording;\n        }\n        return;\n    }\n  });\n  return initialState;\n};\nconst devtools = devtoolsImpl;\nconst parseJsonThen = (stringified, f) => {\n  let parsed;\n  try {\n    parsed = JSON.parse(stringified);\n  } catch (e) {\n    console.error(\n      \"[zustand devtools middleware] Could not parse the received json\",\n      e\n    );\n  }\n  if (parsed !== void 0)\n    f(parsed);\n};\n\nconst subscribeWithSelectorImpl = (fn) => (set, get, api) => {\n  const origSubscribe = api.subscribe;\n  api.subscribe = (selector, optListener, options) => {\n    let listener = selector;\n    if (optListener) {\n      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;\n      let currentSlice = selector(api.getState());\n      listener = (state) => {\n        const nextSlice = selector(state);\n        if (!equalityFn(currentSlice, nextSlice)) {\n          const previousSlice = currentSlice;\n          optListener(currentSlice = nextSlice, previousSlice);\n        }\n      };\n      if (options == null ? void 0 : options.fireImmediately) {\n        optListener(currentSlice, currentSlice);\n      }\n    }\n    return origSubscribe(listener);\n  };\n  const initialState = fn(set, get, api);\n  return initialState;\n};\nconst subscribeWithSelector = subscribeWithSelectorImpl;\n\nconst combine = (initialState, create) => (...a) => Object.assign({}, initialState, create(...a));\n\nfunction createJSONStorage(getStorage) {\n  let storage;\n  try {\n    storage = getStorage();\n  } catch (e) {\n    return;\n  }\n  const persistStorage = {\n    getItem: (name) => {\n      var _a;\n      const parse = (str2) => {\n        if (str2 === null) {\n          return null;\n        }\n        return JSON.parse(str2);\n      };\n      const str = (_a = storage.getItem(name)) != null ? _a : null;\n      if (str instanceof Promise) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (name, newValue) => storage.setItem(name, JSON.stringify(newValue)),\n    removeItem: (name) => storage.removeItem(name)\n  };\n  return persistStorage;\n}\nconst toThenable = (fn) => (input) => {\n  try {\n    const result = fn(input);\n    if (result instanceof Promise) {\n      return result;\n    }\n    return {\n      then(onFulfilled) {\n        return toThenable(onFulfilled)(result);\n      },\n      catch(_onRejected) {\n        return this;\n      }\n    };\n  } catch (e) {\n    return {\n      then(_onFulfilled) {\n        return this;\n      },\n      catch(onRejected) {\n        return toThenable(onRejected)(e);\n      }\n    };\n  }\n};\nconst oldImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    getStorage: () => localStorage,\n    serialize: JSON.stringify,\n    deserialize: JSON.parse,\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage;\n  try {\n    storage = options.getStorage();\n  } catch (e) {\n  }\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const thenableSerialize = toThenable(options.serialize);\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    let errorInSync;\n    const thenable = thenableSerialize({ state, version: options.version }).then(\n      (serializedValue) => storage.setItem(options.name, serializedValue)\n    ).catch((e) => {\n      errorInSync = e;\n    });\n    if (errorInSync) {\n      throw errorInSync;\n    }\n    return thenable;\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      void setItem();\n    },\n    get,\n    api\n  );\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a;\n    if (!storage)\n      return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => cb(get()));\n    const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get())) || void 0;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {\n      if (storageValue) {\n        return options.deserialize(storageValue);\n      }\n    }).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            return options.migrate(\n              deserializedStorageValue.state,\n              deserializedStorageValue.version\n            );\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return deserializedStorageValue.state;\n        }\n      }\n    }).then((migratedState) => {\n      var _a2;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      return setItem();\n    }).then(() => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.getStorage) {\n        storage = newOptions.getStorage();\n      }\n    },\n    clearStorage: () => {\n      storage == null ? void 0 : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  hydrate();\n  return stateFromStorage || configResult;\n};\nconst newImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    storage: createJSONStorage(() => localStorage),\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage = options.storage;\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    return storage.setItem(options.name, {\n      state,\n      version: options.version\n    });\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      void setItem();\n    },\n    get,\n    api\n  );\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a;\n    if (!storage)\n      return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => cb(get()));\n    const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get())) || void 0;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            return options.migrate(\n              deserializedStorageValue.state,\n              deserializedStorageValue.version\n            );\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return deserializedStorageValue.state;\n        }\n      }\n    }).then((migratedState) => {\n      var _a2;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      return setItem();\n    }).then(() => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.storage) {\n        storage = newOptions.storage;\n      }\n    },\n    clearStorage: () => {\n      storage == null ? void 0 : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  hydrate();\n  return stateFromStorage || configResult;\n};\nconst persistImpl = (config, baseOptions) => {\n  if (\"getStorage\" in baseOptions || \"serialize\" in baseOptions || \"deserialize\" in baseOptions) {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\n        \"[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Please use `storage` option instead.\"\n      );\n    }\n    return oldImpl(config, baseOptions);\n  }\n  return newImpl(config, baseOptions);\n};\nconst persist = persistImpl;\n\nexport { combine, createJSONStorage, devtools, persist, redux, subscribeWithSelector };\n","export class ConnectorNotFoundError extends Error {\n  public name: string = 'ConnectorNotFoundError';\n  public message: string = 'Connector not found';\n}\n","export class ConnectorAlreadyConnectedError extends Error {\n  public name: string = 'ConnectorAlreadyConnectedError';\n  public message: string = 'Connector already connected';\n}\n","export class ClientNotFoundError extends Error {\n  public name: string = 'ClientNotFoundError';\n  public message: string = 'Client not found';\n}\n","export enum StatusEnum {\n  CONNECTED = 'connected',\n  CONNECTING = 'connecting',\n  RECONNECTING = 'reconnecting',\n  DISCONNECTED = 'disconnected',\n}\n","import { createStore, Mutate, StoreApi } from 'zustand/vanilla';\nimport { subscribeWithSelector } from 'zustand/middleware';\n\nimport { Connector, ConnectorData } from '../connectors/base';\nimport { ClientNotFoundError } from '../errors';\nimport { StatusEnum } from '../enums';\n\nexport type StateParams = {\n  connectors: Connector[];\n  connector?: Connector;\n  data?: ConnectorData;\n  status?: StatusEnum;\n  autoConnect?: boolean;\n};\n\n\nexport type ClientConfig = StateParams;\n\nexport class Client {\n  private store: Mutate<\n  StoreApi<StateParams>,\n  [\n    ['zustand/subscribeWithSelector', never],\n  ]\n  >;\n\n  private isAutoConnecting: boolean | undefined;\n\n  constructor({\n    autoConnect = false,\n    connectors,\n  }: ClientConfig) {\n    this.store = createStore(subscribeWithSelector(() => ({\n      connectors: connectors,\n      status: StatusEnum.DISCONNECTED,\n      autoConnect,\n    })));\n\n    this.triggerEvent();\n\n    if (autoConnect) {\n      setTimeout(async () => this.autoConnect(), 0);\n    }\n  }\n\n  public get state() {\n    return this.store.getState();\n  }\n\n  public get connector(): Connector | undefined {\n    return this.store.getState().connector;\n  }\n\n  public get connectors(): Connector[] | undefined {\n    return this.store.getState().connectors;\n  }\n\n  public get subscribe() {\n    return this.store.subscribe;\n  }\n\n  public get data() {\n    return this.store.getState().data;\n  }\n\n  public get status() {\n    return this.store.getState().status;\n  }\n\n  public clearState() {\n    this.setState((x: StateParams) => ({\n      ...x,\n      connector: undefined,\n      data: undefined,\n    }));\n  }\n\n  public setState(\n    updater:\n    | Partial<StateParams>\n    | ((\n      state: StateParams,\n    ) => StateParams),\n  ) {\n    const newState =\n      typeof updater === 'function' ? updater(this.store.getState()) : updater;\n    this.store.setState(newState, true);\n  }\n\n  protected async autoConnect() {\n    if (this.isAutoConnecting) {\n      return;\n    }\n    if (this.status === StatusEnum.CONNECTED) {\n      return;\n    }\n    this.isAutoConnecting = true;\n\n    this.setState((x: StateParams) => ({\n      ...x,\n      status: x.data?.activeKey ? StatusEnum.RECONNECTING : StatusEnum.CONNECTING,\n    }));\n\n\n    let isConnected = false;\n    for (const connector of this.connectors || []) {\n      const isConnectedWithConnector = await connector?.isConnected();\n\n      if (isConnectedWithConnector) {\n        await this.connector?.connect();\n        const publicKey = await connector?.getActivePublicKey();\n        this.setState((x: StateParams) => ({\n          ...x,\n          status: StatusEnum.CONNECTED,\n          connector,\n          data: {\n            ...x.data,\n            activeKey: publicKey,\n          },\n        }));\n        isConnected = true;\n\n        break;\n      }\n    }\n\n    if (!isConnected) {\n      this.setState((x: StateParams) => ({\n        ...x,\n        status: StatusEnum.DISCONNECTED,\n      }));\n    }\n\n    this.isAutoConnecting = false;\n\n    return this.data;\n  }\n\n  private triggerEvent(): void {\n    const onChange = (data: ConnectorData) => {\n      this.setState((x: StateParams) => ({\n        ...x,\n        data: { ...x.data, ...data },\n      }));\n    };\n\n    const onDisconnect = () => {\n      this.clearState();\n    };\n\n    const onConnect = (data: ConnectorData) => {\n      this.setState((x: StateParams) => ({\n        ...x,\n        data: { ...x.data, ...data },\n        status: StatusEnum.CONNECTED,\n      }));\n    };\n\n    this.store.subscribe(\n      ({ connector }: StateParams) => connector!,\n      (connector: Connector) => {\n        if (!connector) return;\n        window?.addEventListener('casper:change',\n          (event: CustomEventInit<{ activeKey: string; isConnected: boolean }>) => onChange(event.detail!));\n        window?.addEventListener('casper:disconnect', () => onDisconnect());\n        window?.addEventListener('casper:connect',\n          (event: CustomEventInit<{ activeKey: string; isConnected: boolean }>) => onConnect(event.detail!));\n      },\n    );\n  }\n\n\n}\n\nexport let client: Client;\n\nexport const createClient = (clientConfig: ClientConfig): Client => {\n  client = new Client(clientConfig);\n\n  return client;\n};\n\nexport const getClient = (): Client => {\n  if (!client) {\n    throw new ClientNotFoundError();\n  }\n\n  return client;\n};\n","import { Connector, StatusEnum, ConnectorAlreadyConnectedError } from '@usedapp/core';\nimport { getClient, StateParams } from '@usedapp/core/utils/client';\n\nexport type ConnectParams = {\n  connector: Connector;\n};\n\nexport type ConnectResult = {\n  connector: Connector;\n};\n\nexport const connect = async ({ connector }: ConnectParams): Promise<ConnectResult> => {\n  const client = getClient();\n  const activeConnector = client?.connector;\n\n  if (activeConnector && activeConnector.id !== connector.id) {\n    throw new ConnectorAlreadyConnectedError();\n  }\n\n  try {\n    client.setState((x: StateParams) => ({ ...x, status: StatusEnum.CONNECTING }));\n    await connector.connect();\n    let customData = {};\n    let isConnected = false;\n\n    try {\n      const activeKey = await connector.getActivePublicKey();\n      customData = {\n        activeKey: activeKey,\n      };\n      isConnected = !!activeKey;\n    } catch (err) {\n      console.error(err);\n    }\n\n    client.setState((oldState: StateParams) => ({\n      ...oldState,\n      connector,\n      status: isConnected ? StatusEnum.CONNECTED : StatusEnum.CONNECTING,\n      data: {\n        ...oldState.data,\n        ...customData,\n      },\n    }));\n\n    return {\n      connector,\n    };\n  } catch (error) {\n    console.error(error);\n\n    throw error;\n  }\n};\n","import { StatusEnum } from '@usedapp/core/enums';\nimport { getClient, StateParams } from '@usedapp/core/utils/client';\n\nexport const disconnect = async (): Promise<void> => {\n  const client = getClient();\n\n  try {\n    await client.connector?.disconnect();\n    client.setState((oldState: StateParams) => ({\n      ...oldState,\n      status: StatusEnum.DISCONNECTED,\n      data: {\n        ...oldState.data,\n        activeKey: undefined,\n      },\n    }));\n  } catch (error) {\n    console.error(error);\n  }\n};\n","import { getClient } from '@usedapp/core/utils/client';\n\nexport const isConnected = async (): Promise<boolean> => {\n  const connector = getClient()?.connector;\n\n  try {\n    const hasConnected = await connector?.isConnected();\n\n    return !!hasConnected;\n  } catch (error) {\n    console.error(error);\n    return false;\n  }\n};\n","import { getClient } from '@usedapp/core/utils/client';\n\nexport const getActivePublicKey = async (): Promise<string | undefined> => {\n  const connector = getClient()?.connector;\n\n  try {\n    const activeKey = await connector?.getActivePublicKey();\n\n    return activeKey;\n  } catch (error) {\n    console.error(error);\n  }\n};\n","function shallow(objA, objB) {\n  if (Object.is(objA, objB)) {\n    return true;\n  }\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n    return false;\n  }\n  if (objA instanceof Map && objB instanceof Map) {\n    if (objA.size !== objB.size)\n      return false;\n    for (const [key, value] of objA) {\n      if (!Object.is(value, objB.get(key))) {\n        return false;\n      }\n    }\n    return true;\n  }\n  if (objA instanceof Set && objB instanceof Set) {\n    if (objA.size !== objB.size)\n      return false;\n    for (const value of objA) {\n      if (!objB.has(value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  for (let i = 0; i < keysA.length; i++) {\n    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n  return true;\n}\nvar shallow$1 = (objA, objB) => {\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] default export is deprecated, instead import { shallow } from'zustand/shallow'\"\n    );\n  }\n  return shallow(objA, objB);\n};\n\nexport { shallow$1 as default, shallow };\n","export const deepEqual = (a: any, b: any) => {\n  // check if a and b are both null or undefined\n  if (a === null && b === null) return true;\n  if (a === undefined && b === undefined) return true;\n\n  // check if a and b are of the same type\n  if (typeof a !== typeof b) return false;\n\n  // check if a and b are both primitive types\n  if (typeof a !== 'object') return a === b;\n\n  // check if a and b have the same number of properties\n  if (Object.keys(a as Record<any, any>).length !== Object.keys(b as Record<any, any>).length) return false;\n\n  // check if all properties of a exist in b and are equal\n  // eslint-disable-next-line no-restricted-syntax\n  for (const key in a) {\n    if (!Object.prototype.hasOwnProperty.call(b, key)) return false;\n    if (!deepEqual(a[key], b[key])) return false;\n  }\n\n  return true;\n};\n","import { Connector } from '@usedapp/core/connectors';\nimport { StatusEnum } from '@usedapp/core/enums';\nimport { getClient } from '@usedapp/core/utils';\n\nexport type Account = {\n  publicKey?: string;\n  status?: StatusEnum;\n  connector?: Connector;\n};\n\nexport const getAccount = (): Account | null => {\n  try {\n    const client = getClient();\n    const { data, status, connector } = client;\n\n    return {\n      publicKey: data?.activeKey,\n      status,\n      connector,\n    };\n  } catch (error) {\n    console.error(error);\n\n    return null;\n  }\n};\n","import { shallow } from 'zustand/shallow';\nimport { Connector } from '@usedapp/core/connectors/base';\nimport { StatusEnum } from '@usedapp/core/enums';\nimport { getClient, StateParams } from '@usedapp/core/utils/client';\n\nimport { Account, getAccount } from './getAccount';\n\nexport type Acount = {\n  publicKey: string;\n};\n\nexport type WatchAccountSelectorParams = {\n  publicKey?: string;\n  connector?: Connector;\n  status?: StatusEnum;\n};\n\nexport type WatchAccountOptions = {\n  selector?: ({\n    publicKey,\n    connector,\n    status,\n  }: WatchAccountSelectorParams) => any;\n};\n\nexport const watchAccount = (\n  callback: (account: Account | null) => void,\n  { selector = (params: WatchAccountSelectorParams) => params } : WatchAccountOptions = {}): any => {\n  const client = getClient();\n\n  const handleOnChange = () => callback(getAccount());\n  const unsubscribe = client.subscribe(\n    ({ data, connector, status }: StateParams) => {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      return selector?.({\n        publicKey: data?.activeKey,\n        status,\n        connector,\n      });\n    },\n    handleOnChange,\n    {\n      equalityFn: shallow,\n    },\n  );\n\n  return unsubscribe;\n};\n","import { getClient } from '@usedapp/core/utils/client';\nimport { JsonTypes } from 'typedjson';\n\nexport type SignParams = {\n  deploy: unknown;\n  signingPublicKey: string;\n  targetPublicKeyHex: string;\n};\n\nexport type SignResult = { deploy: JsonTypes } | undefined;\n\nexport const sign = async ({ deploy, signingPublicKey, targetPublicKeyHex }: SignParams): Promise<SignResult> => {\n  const connector = getClient()?.connector;\n\n  try {\n    return await connector?.sign(deploy, signingPublicKey, targetPublicKeyHex);\n  } catch (error) {\n    console.error(error);\n  }\n};\n","import { getClient } from '@usedapp/core/utils/client';\n\nexport type SignMessageParams = {\n  message: string;\n  signingPublicKey: string;\n};\n\nexport type SignMessageResult = string | undefined;\n\nexport const signMessage = async ({ message, signingPublicKey }: SignMessageParams): Promise<SignMessageResult> => {\n  const connector = getClient()?.connector;\n\n  try {\n    return await connector?.signMessage(message, signingPublicKey);\n  } catch (error) {\n    console.error(error);\n  }\n};\n","import { default as EventEmitter } from 'eventemitter3';\nimport { JsonTypes } from 'typedjson';\n\nexport type ConnectorData<Provider = unknown> = {\n  activeKey?: string;\n  isConnected?: boolean;\n  provider?: Provider;\n};\n\nexport interface ConnectorEvents {\n  change(data: ConnectorData): void;\n  connect(data: ConnectorData): void;\n  message({ type, data }: { type: string; data?: unknown }): void;\n  disconnect(): void;\n  error(error: Error): void;\n}\n\nexport abstract class Connector<Provider = unknown, EventProvider = unknown, Options = unknown> extends EventEmitter<ConnectorEvents> {\n  protected readonly options: Options;\n  public abstract readonly id: string;\n\n  constructor({\n    options,\n  }: {\n    options: Options;\n  }) {\n    super();\n    this.options = options;\n  }\n\n  public getOptions() {\n    return this.options;\n  }\n\n  public abstract getProvider(): Promise<Provider>;\n  public abstract getEventProvider(): Promise<EventProvider>;\n\n  public abstract isConnected(): Promise<boolean>;\n  public abstract disconnect(): Promise<void>;\n  public abstract connect(): Promise<void>;\n  public abstract getActivePublicKey(): Promise<string>;\n  public abstract signMessage(message:string, signingPublicKey: string): Promise<string>;\n  public abstract sign(deploy: unknown, signingPublicKeyHex: string, targetPublicKeyHex: string): Promise<{ deploy: JsonTypes }>;\n\n  public abstract onConnected(event: CustomEventInit): void;\n  public abstract onDisconnected(): void;\n  public abstract onActiveKeyChanged(event: CustomEventInit): void;\n}\n","import { JsonTypes } from 'typedjson';\n\nimport { ConnectorNotFoundError } from '../errors';\n\nimport { Connector } from './base';\n\ndeclare global {\n  interface Window {\n    casperDashPluginHelpers?: {\n      isConnected: () => Promise<boolean>;\n      signMessage: (message: string, signingPublicKey: string) => Promise<string>;\n      sign: (deploy: unknown, signingPublicKey: string, targetPublicKey: string) => Promise<{ deploy: JsonTypes }>;\n      disconnectFromSite: () => Promise<void>;\n      requestConnection: () => Promise<void>;\n      getActivePublicKey: () => Promise<string>;\n    };\n  }\n}\n\ntype CasperDashWindowGlobal = Window['casperDashPluginHelpers'];\ntype Provider = CasperDashWindowGlobal;\ntype EventProvider = Window;\n\nexport type CasperDashConnectorOptions = {\n  name?: string;\n  getProvider?: () => Provider;\n  getEventProvider?: () => EventProvider;\n};\n\nexport class CasperDashConnector extends Connector<CasperDashWindowGlobal, Window, CasperDashConnectorOptions> {\n  public readonly id: string = 'casperDash';\n\n  private provider: Provider;\n  private eventProvider: Window | undefined;\n\n  constructor({\n    options: defaultOptions,\n  }: { options?: CasperDashConnectorOptions } = {}) {\n    const options: CasperDashConnectorOptions = {\n      name: 'CasperDash',\n      getProvider: (): Provider | undefined => {\n        return typeof window !== 'undefined' ? window.casperDashPluginHelpers : undefined;\n      },\n      getEventProvider: (): EventProvider => {\n        return window;\n      },\n      ...defaultOptions,\n    };\n\n    super({ options });\n  }\n\n  public async getProvider(): Promise<CasperDashWindowGlobal> {\n    const provider = this.options.getProvider?.();\n    if (!provider) {\n      throw new ConnectorNotFoundError();\n    }\n    this.provider = provider;\n\n    return this.provider;\n  }\n\n  public async getEventProvider(): Promise<EventProvider> {\n    const eventProvider = this.options.getEventProvider?.();\n    if (!eventProvider) {\n      throw new ConnectorNotFoundError();\n    }\n\n    this.eventProvider = eventProvider;\n\n    return this.eventProvider;\n  }\n\n  public async isConnected(): Promise<boolean> {\n    try {\n      const provider = await this.getProvider();\n\n      return await provider!.isConnected();\n    } catch (err) {\n      return false;\n    }\n  }\n\n  public async disconnect(): Promise<void> {\n    const provider = await this.getProvider();\n\n    const eventProvider = await this.getEventProvider();\n\n    eventProvider?.removeEventListener('casperdash:activeKeyChanged', this.onActiveKeyChanged);\n    eventProvider?.removeEventListener('casperdash:disconnected', () => this.onDisconnected());\n    eventProvider?.removeEventListener('casperdash:connected', this.onConnected);\n\n    await provider!.disconnectFromSite();\n  }\n\n  public async connect(): Promise<void> {\n    const provider = await this.getProvider();\n\n    const eventProvider = await this.getEventProvider();\n\n    eventProvider?.addEventListener('casperdash:activeKeyChanged', this.onActiveKeyChanged);\n    eventProvider?.addEventListener('casperdash:disconnected', this.onDisconnected);\n    eventProvider?.addEventListener('casperdash:connected', this.onConnected);\n\n    await provider!.requestConnection();\n  }\n\n  public async getActivePublicKey(): Promise<any> {\n    const provider = await this.getProvider();\n\n    return provider!.getActivePublicKey();\n  }\n\n  public async signMessage(message: string, signingPublicKey: string): Promise<string> {\n    const provider = await this.getProvider();\n\n    return provider!.signMessage(message, signingPublicKey);\n  }\n\n  public async sign(deploy: any, signingPublicKey: string, targetPublicKey: string): Promise<{ deploy: JsonTypes }> {\n    const provider = await this.getProvider();\n\n    return provider!.sign(deploy, signingPublicKey, targetPublicKey);\n  }\n\n  public onDisconnected(): void {\n    const customEvent = new CustomEvent('casper:disconnect');\n    window.dispatchEvent(customEvent);\n    // this.emit('disconnect');\n  }\n\n  public onActiveKeyChanged(event: CustomEventInit<{ activeKey: string; isConnected: boolean }>): void {\n    const customEvent = new CustomEvent('casper:change', event);\n    window.dispatchEvent(customEvent);\n    // this.emit('change', { isConnected: event.detail?.isConnected, activeKey: event.detail?.activeKey });\n  }\n\n  public onConnected(event: CustomEventInit<{ activeKey: string; isConnected: boolean }>): void {\n    const customEvent = new CustomEvent('casper:connect', event);\n    window.dispatchEvent(customEvent);\n    // this.emit('connect', { isConnected: event.detail?.isConnected, activeKey: event.detail?.activeKey });\n  }\n}\n","import { JsonTypes } from 'typedjson';\n\nimport { ConnectorNotFoundError } from '../errors';\nimport { CasperLabsHelper } from '../types/casperLabsHelper';\n\nimport { Connector } from './base';\n\ndeclare global {\n  interface Window {\n    casperlabsHelper: CasperLabsHelper;\n  }\n}\n\n\ntype CasperLabWindowGlobal = CasperLabsHelper;\ntype Provider = CasperLabsHelper;\ntype EventProvider = Window;\n\nexport type CasperSignerConnectorOptions = {\n  name?: string;\n  getProvider?: () => Provider | undefined;\n  getEventProvider?: () => EventProvider;\n};\n\nexport class CasperSignerConnector extends Connector<CasperLabWindowGlobal, Window, CasperSignerConnectorOptions> {\n  public readonly id: string = 'casperSigner';\n\n  private provider: Provider | undefined;\n  private eventProvider: Window | undefined;\n\n  constructor({\n    options: defaultOptions,\n  }: { options?: CasperSignerConnectorOptions } = {}) {\n    const options = {\n      name: 'CasperSigner',\n      getProvider: (): Provider | undefined => {\n        return typeof window !== 'undefined' ? window.casperlabsHelper : undefined;\n      },\n      getEventProvider: (): EventProvider => {\n        return window;\n      },\n      ...defaultOptions,\n    };\n\n    super({ options });\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  public async getProvider(): Promise<CasperLabWindowGlobal> {\n    const provider = this.options.getProvider?.();\n    if (!provider) {\n      throw new ConnectorNotFoundError();\n    }\n    this.provider = provider;\n\n    return this.provider;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  public async getEventProvider(): Promise<EventProvider> {\n    const eventProvider = this.options.getEventProvider?.();\n    if (!eventProvider) {\n      throw new ConnectorNotFoundError();\n    }\n\n    this.eventProvider = eventProvider;\n\n    return this.eventProvider;\n  }\n\n  public async isConnected(): Promise<boolean> {\n    try {\n      const provider = await this.getProvider();\n\n      return await provider.isConnected();\n    } catch (err) {\n      return false;\n    }\n  }\n\n  public async disconnect(): Promise<void> {\n    const provider = await this.getProvider();\n\n    const eventProvider = await this.getEventProvider();\n\n    eventProvider?.removeEventListener('signer:activeKeyChanged', this.onActiveKeyChanged);\n    eventProvider?.removeEventListener('signer:disconnected', this.onDisconnected);\n    eventProvider?.removeEventListener('signer:connected', this.onConnected);\n\n    provider.disconnectFromSite();\n  }\n\n  public async connect(): Promise<void> {\n    const provider = await this.getProvider();\n\n    const eventProvider = await this.getEventProvider();\n\n    eventProvider?.addEventListener('signer:activeKeyChanged', this.onActiveKeyChanged);\n    eventProvider?.addEventListener('signer:disconnected',  this.onDisconnected);\n    eventProvider?.addEventListener('signer:connected', this.onConnected);\n\n    provider.requestConnection();\n  }\n\n  public async getActivePublicKey(): Promise<string> {\n    const provider = await this.getProvider();\n\n    return provider.getActivePublicKey();\n  }\n\n  public async signMessage(message: string, signingPublicKey: string): Promise<string> {\n    const provider = await this.getProvider();\n\n    return provider.signMessage(message, signingPublicKey);\n  }\n\n  public async sign(deploy: any, signingPublicKeyHex: string, targetPublicKeyHex: string): Promise<{ deploy: JsonTypes }> {\n    const provider = await this.getProvider();\n\n    return provider.sign(deploy, signingPublicKeyHex, targetPublicKeyHex);\n  }\n\n  public onDisconnected(): void {\n    const customEvent = new CustomEvent('casper:disconnect');\n    window.dispatchEvent(customEvent);\n    // this.emit('disconnect');\n  }\n\n  public onActiveKeyChanged(event: CustomEventInit<{ activeKey: string; isConnected: boolean }>): void {\n    const customEvent = new CustomEvent('casper:change', event);\n    window.dispatchEvent(customEvent);\n    // this.emit('change', { isConnected: event.detail?.isConnected, activeKey: event.detail?.activeKey });\n  }\n\n  public onConnected(event: CustomEventInit<{ activeKey: string; isConnected: boolean }>): void {\n    const customEvent = new CustomEvent('casper:connect', event);\n    window.dispatchEvent(customEvent);\n    // this.emit('connect', { isConnected: event.detail?.isConnected, activeKey: event.detail?.activeKey });\n  }\n}\n"],"mappings":"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","names":["EventEmitter","StatusEnum","isConnected","client","isConnected","client","client","client","Connector","EventEmitter","Connector","Connector"]}